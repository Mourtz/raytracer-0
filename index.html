<html>

<head>
  <title>WebGL2 Raytracer - Enhanced ReSTIR Temporal Reuse</title>
  <!--Let browser know website is optimized for mobile-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!--  CSS  -->
  <link href="index.css" rel="stylesheet">
  <!--Import materialize.css-->
  <link type="text/css" rel="stylesheet" href="external/css/materialize.min.css" media="screen,projection" />
</head>

<body>
  <div id="intro">
    <h4>Loading...</h4>
    <div id="stats"></div>
  </div>
  <div id="ff" hidden>
    <div class="progress">
      <div class="determinate" style="width: 0%"></div>
    </div>
    <div id="glslViewport"></div>
    <div id="settings">
      <h4>Settings</h4>

      <div id="checkboxes">
        <div class="mutually-exclusive-group">
          <div>
            <input type="checkbox" id="u_cubemap" checked="checked" onchange="updateParams(this);" />
            <label for="u_cubemap">CUBEMAP</label>
          </div>

          <div>
            <input type="checkbox" id="u_procedural_sky" onchange="updateParams(this);" />
            <label for="u_procedural_sky">PROCEDURAL SKY</label>
          </div>
        </div>

        <div>
          <input type="checkbox" id="u_biased_sampling" checked="checked" onchange="updateParams(this);" />
          <label for="u_biased_sampling">BIASED</label>
        </div>

        <div>
          <input type="checkbox" id="sample_lights" checked="checked" onchange="updateParams(this);" />
          <label for="sample_lights">SAMPLE LIGHTS</label>
        </div>

        <div>
          <input type="checkbox" id="use_mis" onchange="updateParams(this);" />
          <label for="use_mis">MIS</label>
        </div>

        <div>
          <input type="checkbox" id="use_restir" onchange="updateParams(this);" />
          <label for="use_restir">Enhanced ReSTIR (Multi-Frame Temporal)</label>
        </div>

        <div id="animation_status" style="display: none; color: #ff6b35; font-weight: bold; margin-top: 10px;">
          ðŸŽ¬ ANIMATED SCENE - Real-time ReSTIR Demo
        </div>

        <!--
        <div>
          <input type="checkbox" id="u_biDirectional" onchange="updateParams(this);" />
          <label for="u_biDirectional">BI-DIRECTIONAL</label>
        </div>
-->
      </div>

      <br>

      <div class="input-field col s12">
        <select id="size_select" onchange='size_select(Number(this.value));'>
          <option id="default_size" value="-1" disabled selected>Default</option>
          <option value="0">256x256</option>
          <option value="1">512x512</option>
          <option value="2">1024x1024</option>
          <option value="3">2048x2048</option>
          <option value="4">4096x4096</option>
          <option value="5">8192x8192(on your own risk!)</option>
        </select>
        <label>Output resolution</label>
      </div>

      <!-- Scene Select -->
      <div class="input-field col s12">
        <select onchange='scene_select(Number(this.value));'>
          <option value="0" selected>Default</option>
          <option value="1">Cornell Box</option>
          <option value="2">Mandelbulb</option>
          <option value="3">MengerSponge</option>
          <option value="4">MIS Demo</option>
          <option value="5">Enhanced ReSTIR Demo (9 lights)</option>
          <option value="6">ReSTIR Stress Test (25+ lights)</option>
          <option value="7">Animated ReSTIR Showcase (Real-time)</option>
        </select>
        <label>Scene Select - Try Enhanced ReSTIR scenes!</label>
      </div>

      <!-- Passes -->
      <p class="range-field">
        <label>Passes</label>
        <input type="range" id="passes" min="1" max="1e4" value="64" onchange="updateParams(this);" />
      </p>

      <!-- Temporal Accumulation for Animated Scenes -->
      <p class="range-field" id="temporal_accumulation_slider" style="display: none;">
        <label>Temporal Accumulation (frames)</label>
        <input type="range" id="temporal_frames" min="1" max="16" value="5" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Raymarching Steps</label>
        <input type="range" id="m_steps" min="64" max="512" value="128" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Bounces</label>
        <input type="range" id="max_bounces" min="1" max="24" value="12" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Diffuse Bounces</label>
        <input type="range" id="max_diff" min="1" max="24" value="4" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Specular Bounces</label>
        <input type="range" id="max_spec" min="1" max="24" value="4" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Transmission Bounces</label>
        <input type="range" id="max_trans" min="1" max="24" value="12" onchange="updateParams(this);" />
      </p>

      <p class="range-field">
        <label>Max Scattering Events</label>
        <input type="range" id="max_scatter" min="1" max="24" value="12" onchange="updateParams(this);" />
      </p>

      <!-- Button Groups -->
      <div class="button-row">
        <a class="waves-effect waves-light btn" onclick="rendering=false; sandbox.clear();">Clear</a>
        <a class="waves-effect waves-light btn" id="renderBtn" onclick="draw();">Render</a>
      </div>

      <div class="button-row">
        <a class="waves-effect waves-light btn" id="compileBtn" onclick="recompile()">Compile</a>
        <a class="waves-effect waves-light btn" id="liveBtn" onclick="updateParams(this);">Live</a>
      </div>

      <div class="button-row">
        <a class="waves-effect waves-light btn" id="debugBtn" onclick="toggleBufferDisplay();">Show All Buffers</a>
        <a class="waves-effect waves-light btn modal-trigger" id="infoBtn" href="#modal1">Controls</a>
      </div>
    </div>

    <div>
      <!--   Scene modifier wrapper   -->
      <div id="scene_wrapper">
        Current Scene:<br>
        <textarea id="scene"
          oninput='this.style.height = "1px"; this.style.height = this.scrollHeight+"px"; $("#compileBtn").css("background", "linear-gradient(135deg, #dc2626, #ef4444)"); is_live = false; $("#liveBtn").css("background-color", "rgb(105, 105, 105)");'>MAT_METAL, SDF, vec3(0.0, -0.49, 0.0), vec4(1.0)
MAT_WHITE, SDF, vec3(0.0, -1.6, -0.2), vec4(1.5,0.1,1.5,0.0)</textarea>
      </div>

      <!--   SDF selector   -->
      <div id="sdf_meshes">

      </div>
    </div>

  </div>

  <div id="modal1" class="modal">
    <div class="modal-content">
      <p>
        <b>Controls:</b><br> 
        W/A/S/D/Q/E to modify camera's origin,<br> 
        UP/LEFT/DOWN/RIGHT arrow to modify camera's concentration point position,<br> 
        1/! to increase/decrease the field of view,<br> 
        2/@ to increase/decrease the aperture size,<br> 
        3/# to increase/decrease the focal length,<br> 
        <b>D</b> to toggle enhanced debug display (3x2 grid with temporal history),<br>
        <b>V</b> to show detailed ReSTIR debug information,<br>
        <b>C</b> to center debug divider (when in debug mode),<br>
        <b>Mouse drag</b> to adjust debug view in grid mode,<br>
        SPACE to reset camera,<br> 
        R to reset view direction,<br> 
        Esc to stop
      </p>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
    </div>
  </div>

  <!--	   jQuery 2.2.4      -->
  <script src="external/js/jquery.min.js"></script>
  <!--	Materializecss  -->
  <script src="external/js/materialize.min.js"></script>
  <!--	@mrdoob stats.js -->
  <script src="external/js/stats.min.js"></script>
  <!--    Custom GL Tools    -->
  <script src="tools.js"></script>
  <!--      Vector3      -->
  <script src="vector.js"></script>
  <!--         index         -->
  <script src="index.js"></script>

  <script>
    const w_size = window.innerWidth / 2.5;
    const cubemap_dir = "Tropical%20Beach";

    $("#ff .progress").css("width", w_size);
    $("#size_select #default_size").html(Math.round(w_size) + "x" + Math.round(w_size));

    let shaders = [{
      "name": 'vertex_shader',
      "type": 'vert',
      "filepath": "shaders/vert.glsl"
    },
    {
      "name": 'raytracing_shader',
      "type": 'frag',
      "filepath": "shaders/pathtracing/raytracer.glsl"
    },
    {
      "name": 'display_shader',
      "type": 'frag',
      "filepath": "shaders/tonemapper.glsl"
    },
    {
      "name": 'debug_display_shader',
      "type": 'frag',
      "filepath": "shaders/debug_display.glsl"
    }
    ];

    let sandbox = new GlslViewport(null, {
      tile_rendering: false,
      shaders: shaders,
      textures: ["textures/tex0.png", "textures/tex1.png", "textures/tex2.png", "textures/tex3.png"],

      //"cubemaps/Yokohama/negx.jpg",  "cubemaps/Yokohama/negy.jpg", "cubemaps/Yokohama/negz.jpg",
      //"cubemaps/Yokohama/posx.jpg",  "cubemaps/Yokohama/posy.jpg", "cubemaps/Yokohama/posz.jpg"

      cubemap: [
        "cubemaps/" + cubemap_dir + "/left.jpg", "cubemaps/" + cubemap_dir + "/bottom.jpg", "cubemaps/" + cubemap_dir + "/back.jpg",
        "cubemaps/" + cubemap_dir + "/right.jpg", "cubemaps/" + cubemap_dir + "/top.jpg", "cubemaps/" + cubemap_dir + "/front.jpg"
      ],
      width: w_size * window.devicePixelRatio,
      height: w_size * window.devicePixelRatio,
      max_passes: 64,
      paused: false,
      preserveDrawingBuffer: false
    });

    document.addEventListener("textures_loaded", function () {
      document.getElementById("ff").attributes.removeNamedItem("hidden");
      $("#intro h4").html("WebGL Pathtracer");
      size_select(-1);
    });

    // @mrdoob stats.js
    let stats = new Stats();
    stats.showPanel(0);
    document.body.appendChild(stats.dom);
    document.getElementById("glslViewport").appendChild(sandbox.canvas);

    // Add enhanced debug labels overlay for 3x2 grid
    const debugLabels = document.createElement('div');
    debugLabels.className = 'debug-labels';
    debugLabels.id = 'debugLabels';
    debugLabels.innerHTML = `
      <div class="debug-label main" id="labelMain">MAIN RENDER</div>
      <div class="debug-label effectiveness" id="labelEffectiveness">ReSTIR EFFECTIVENESS</div>
      <div class="debug-label temporal" id="labelTemporal">TEMPORAL ANALYSIS</div>
      <div class="debug-label samples" id="labelSamples">SAMPLE COUNT (M)</div>
      <div class="debug-label age" id="labelAge">AGE & LIGHT INDEX</div>
      <div class="debug-label contribution" id="labelContribution">LIGHT CONTRIBUTIONS</div>
    `;
    document.getElementById("glslViewport").appendChild(debugLabels);

    $("#glslViewport canvas").css("width", w_size);
    $("#glslViewport canvas").css("height", w_size);

    let lastDownTarget = undefined;

    document.addEventListener('mousedown', function (evt) {
      lastDownTarget = evt.target;

    }, false);

    // Debug divider interaction
    let isDraggingDivider = false;
    
    document.addEventListener('mousedown', function (evt) {
      if (evt.target === sandbox.canvas && sandbox.showAllBuffers) {
        const rect = sandbox.canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) / rect.width;
        const y = 1.0 - (evt.clientY - rect.top) / rect.height; // Flip Y for OpenGL coordinates
        
        // Check if clicking near the divider center
        const centerDist = Math.sqrt(
          Math.pow(x - sandbox.debugDividerPos[0], 2) + 
          Math.pow(y - sandbox.debugDividerPos[1], 2)
        );
        
        if (centerDist < 0.05) { // Within 5% of screen size
          isDraggingDivider = true;
          evt.preventDefault();
        }
      }
    }, false);
    
    document.addEventListener('mousemove', function (evt) {
      if (isDraggingDivider && sandbox.showAllBuffers) {
        const rect = sandbox.canvas.getBoundingClientRect();
        const x = Math.max(0.1, Math.min(0.9, (evt.clientX - rect.left) / rect.width));
        const y = Math.max(0.1, Math.min(0.9, 1.0 - (evt.clientY - rect.top) / rect.height));
        
        sandbox.updateDividerPosition(x, y);
        sandbox.render();
        updateDebugLabels();
        
        evt.preventDefault();
      }
    }, false);
    
    document.addEventListener('mouseup', function (evt) {
      isDraggingDivider = false;
    }, false);

    const cam_step = 0.1;
    const cam_rot_step = 0.05;
    const cam_aperture_step = 0.001;

    let flagY = false;
    let flagZ = false;

    document.addEventListener('keydown', function (evt) {

      if (lastDownTarget == $("#glslViewport canvas").get(0)) {
        let gl = sandbox.gl;
        //      sandbox.keyboardTexVal[evt.keyCode] = 1;
        //
        //      gl.activeTexture(gl.TEXTURE0 + keyboardTexPos);
        //      gl.bindTexture(gl.TEXTURE_2D, sandbox.textures["keyboard_tex"]["tex"]);
        //      gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, 256, 1, 0, gl.RED, gl.UNSIGNED_BYTE, sandbox.keyboardTexVal);

        let refresh = true;

        if (evt.code === "Escape") {
          sandbox.passes = sandbox.max_passes;
          return;
        } else if (evt.code === "Space") { // Spacebar - reset camera
          sandbox.camera.origin = new Vector3(0.0, 0.0, 3.0);
          sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
          sandbox.camera.fov = 90.0;
          sandbox.camera.aperture = 0.01;
          sandbox.camera.focalLength = 10.0;
          flagY = false;
          flagZ = false;
        } else if (evt.keyCode === 82) sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0); // R - reset view direction
        else if (evt.keyCode === 65) sandbox.camera.origin.x -= cam_step; // A
        else if (evt.keyCode === 68) sandbox.camera.origin.x += cam_step; // D
        else if (evt.keyCode === 87) sandbox.camera.origin.z -= cam_step; // W
        else if (evt.keyCode === 83) sandbox.camera.origin.z += cam_step; // S
        else if (evt.keyCode === 81) sandbox.camera.origin.y -= cam_step; // Q
        else if (evt.keyCode === 69) sandbox.camera.origin.y += cam_step; // E
        else if (evt.key === "ArrowUp") {
          if (!flagY) {
            sandbox.camera.lookat.y += cam_rot_step;
            if (sandbox.camera.lookat.y > 1.0) {
              sandbox.camera.lookat.z *= -1;
              flagY = !flagY;
            }
          } else {
            sandbox.camera.lookat.y -= cam_rot_step;
            if (sandbox.camera.lookat.y < -1.0) {
              sandbox.camera.lookat.z *= -1;
              flagY = !flagY;
            }
          }
        } else if (evt.key === "ArrowDown") {
          if (flagY) {
            sandbox.camera.lookat.y += cam_rot_step;
            if (sandbox.camera.lookat.y > 1.0) {
              sandbox.camera.lookat.z *= -1;
              flagY = !flagY;
            }
          } else {
            sandbox.camera.lookat.y -= cam_rot_step;
            if (sandbox.camera.lookat.y < -1.0) {
              sandbox.camera.lookat.z *= -1;
              flagY = !flagY;
            }
          }
        } else if (evt.key === "ArrowLeft") {
          if (!flagZ) {
            sandbox.camera.lookat.x -= cam_rot_step;
            if (sandbox.camera.lookat.x < -1.0) {
              sandbox.camera.lookat.z *= -1;
              flagZ = !flagZ;
            }
          } else {
            sandbox.camera.lookat.x += cam_rot_step;
            if (sandbox.camera.lookat.x > 1.0) {
              sandbox.camera.lookat.z *= -1;
              flagZ = !flagZ;
            }
          }
        } else if (evt.key === "ArrowRight") {
          if (flagZ) {
            sandbox.camera.lookat.x -= cam_rot_step;
            if (sandbox.camera.lookat.x < -1.0) {
              sandbox.camera.lookat.z *= -1;
              flagZ = !flagZ;
            }
          } else {
            sandbox.camera.lookat.x += cam_rot_step;
            if (sandbox.camera.lookat.x > 1.0) {
              sandbox.camera.lookat.z *= -1;
              flagZ = !flagZ;
            }
          }
        } else if (evt.key === "1") sandbox.camera.fov = Math.min(130, sandbox.camera.fov + 1);
        else if (evt.key === "!") sandbox.camera.fov = Math.max(5, sandbox.camera.fov - 1);
        else if (evt.key === "2") sandbox.camera.aperture = Math.min(0.1, sandbox.camera.aperture + cam_aperture_step);
        else if (evt.key === "@") sandbox.camera.aperture = Math.max(0.0, sandbox.camera.aperture - cam_aperture_step);
        else if (evt.key === "3") sandbox.camera.focalLength += 0.1;
        else if (evt.key === "#") sandbox.camera.focalLength = Math.max(0.1, sandbox.camera.focalLength - 0.1);
        else if (evt.key === "d" || evt.key === "D") { // D - toggle enhanced debug display
          toggleBufferDisplay();
          refresh = false; // Don't refresh camera for this action
        }
        else if (evt.key === "v" || evt.key === "V") { // V - ReSTIR debug info
          sandbox.toggleReSTIR();
          refresh = false; // Don't refresh camera for this action
        }
        else if (evt.key === "c" || evt.key === "C") { // C - center debug divider
          if (sandbox.showAllBuffers) {
            sandbox.resetDebugDivider();
            updateDebugLabels();
            refresh = false; // Don't refresh camera for this action
          }
        }
        else refresh = false;

        if (refresh) {
          $("#intro #stats").html("<b>camera</b> pos: " + sandbox.camera.origin.x.toFixed(3) + ", " + sandbox.camera.origin.y.toFixed(3) + ", " + sandbox.camera.origin.z.toFixed(3) +
            " | dir: " + sandbox.camera.lookat.x.toFixed(3) + ", " + sandbox.camera.lookat.y.toFixed(3) + ", " + sandbox.camera.lookat.z.toFixed(3) + "<br>" +
            " fov: " + sandbox.camera.fov + ", aperture: " + sandbox.camera.aperture.toFixed(3) + ", focal length: " + sandbox.camera.focalLength.toFixed(3));

          gl.useProgram(sandbox.frontTarget.program);

          gl.uniform3f(sandbox.frontTarget.camPosID, sandbox.camera.origin.x, sandbox.camera.origin.y, sandbox.camera.origin.z);
          gl.uniform3f(sandbox.frontTarget.camLookAtID, sandbox.camera.lookat.x, sandbox.camera.lookat.y, sandbox.camera.lookat.z);
          gl.uniform3f(sandbox.frontTarget.camParamsID, sandbox.camera.fov, sandbox.camera.aperture, sandbox.camera.focalLength);

          sandbox.passes = 0;
          sandbox.clear();
        }

      }

    }, false);

    let rendering = false;
    let is_live = false;

    function markNeedsRecompilation() {
      $("#compileBtn").css("background", "linear-gradient(135deg, #dc2626, #ef4444)");
      is_live = false;
      $("#liveBtn").css("background-color", "rgb(105, 105, 105)");
    }

    function updateParams(el) {

      if (el.id == "liveBtn") {
        is_live = !is_live;
        $("#liveBtn").css("background-color", is_live ? "rgb(255, 0, 0)" : "rgb(105, 105, 105)");
      } else if (el.type == "range") {
        if (el.id === "passes") {
          sandbox.max_passes = el.value;
          return;
        } else {
          sandbox.gl.useProgram(sandbox.frontTarget.program);

          if (el.id === "m_steps") {
            sandbox.constants[5] = "const mediump int MARCHING_STEPS = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "max_bounces") {
            $('#max_diff').attr("max", el.value);
            $('#max_spec').attr("max", el.value);
            $('#max_trans').attr("max", el.value);
            $('#max_scatter').attr("max", el.value);

            sandbox.constants[0] = "const lowp int MAX_BOUNCES = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "max_diff") {
            sandbox.constants[1] = "const lowp int MAX_DIFF_BOUNCES = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "max_spec") {
            sandbox.constants[2] = "const lowp int MAX_SPEC_BOUNCES = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "max_trans") {
            sandbox.constants[3] = "const lowp int MAX_TRANS_BOUNCES = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "max_scatter") {
            sandbox.constants[4] = "const lowp int MAX_SCATTERING_EVENTS = " + el.value + ";";
            markNeedsRecompilation();
          } else if (el.id === "temporal_frames") {
            sandbox.temporalFrames = parseInt(el.value);
          } else {
            return console.error();
          }
        }

      } else if (el.type == "checkbox") {
        console.log("Checkbox changed:", el.id, "checked:", el.checked);
        if (el.id == "u_cubemap") {
          sandbox.defines[0] = el.checked ? "#define USE_CUBEMAP" : "//#define USE_CUBEMAP";
          console.log("Updated USE_CUBEMAP:", sandbox.defines[0]);
          markNeedsRecompilation();

          // Disable PROCEDURAL SKY when CUBEMAP is enabled
          if (el.checked) {
            $("#u_procedural_sky").prop('checked', false);
            sandbox.defines[1] = "//#define USE_PROCEDURAL_SKY";
            console.log("Auto-disabled USE_PROCEDURAL_SKY");
          }
        } else if (el.id == "u_procedural_sky") {
          sandbox.defines[1] = el.checked ? "#define USE_PROCEDURAL_SKY" : "//#define USE_PROCEDURAL_SKY";
          console.log("Updated USE_PROCEDURAL_SKY:", sandbox.defines[1]);
          markNeedsRecompilation();

          // Disable CUBEMAP when PROCEDURAL SKY is enabled
          if (el.checked) {
            $("#u_cubemap").prop('checked', false);
            sandbox.defines[0] = "//#define USE_CUBEMAP";
            console.log("Auto-disabled USE_CUBEMAP");
          }
        } else if (el.id == "u_biased_sampling") {
          sandbox.defines[2] = el.checked ? "#define USE_BIASED_SAMPLING" : "//#define USE_BIASED_SAMPLING";
          console.log("Updated USE_BIASED_SAMPLING:", sandbox.defines[2]);
          markNeedsRecompilation();
        } else if (el.id == "sample_lights") {
          sandbox.constants[7] = "const bool sample_lights = " + el.checked + ";";
          console.log("Updated sample_lights:", sandbox.constants[7]);
          markNeedsRecompilation();
        } else if (el.id == "use_mis") {
          sandbox.constants[8] = "const bool use_mis = " + el.checked + ";";
          console.log("Updated use_mis:", sandbox.constants[8]);
          markNeedsRecompilation();
        } else if (el.id == "use_restir") {
          sandbox.constants[9] = "const bool use_restir = " + el.checked + ";";
          sandbox.defines[4] = el.checked ? "#define USE_RESTIR" : "//#define USE_RESTIR";
          console.log("Updated use_restir:", sandbox.constants[9]);
          console.log("Updated USE_RESTIR:", sandbox.defines[4]);
          
          // Show/hide enhanced ReSTIR info panel
          const restirInfo = document.getElementById("restir_info");
          if (restirInfo) {
            restirInfo.style.display = el.checked ? "block" : "none";
          }
          
          markNeedsRecompilation();
        } else if (el.id == "u_biDirectional") {
          sandbox.defines[3] = el.checked ? "#define USE_BIDIRECTIONAL" : "//#define USE_BIDIRECTIONAL";
          console.log("Updated USE_BIDIRECTIONAL:", sandbox.defines[3]);
          markNeedsRecompilation();

          if (el.checked) {
            $("#sample_lights").prop('checked', true);
            sandbox.constants[7] = "const bool sample_lights = true;";
          }
        } else {
          return console.error();
        }

      } else if (el.type == "textarea") {
        if (el.id == "scene") {

          let NUM_MESHES = 0;
          let NUM_SDFS = 0;
          let NUM_MODELS = 0;

          let U_SPHERE = false; // using Euclidean sphere?
          let U_PLANE = false; // using Euclidean plane?
          let U_BOX = false; // using Non-Euclidean box?
          let U_SDF = false; // using SDF meshes?

          let light_indices = [];

          let line = el.text.split("\n");
          let text = [];

          for (let i = 0; i < line.length; i++) {

            let fields = line[i].split(",");

            let mat = fields[0].trim();
            if (mat.lastIndexOf("MAT_LIGHT") >= 0) {
              light_indices.push(i);
            }
            let type = fields[1].trim();

            text[i] = "Mesh(" + line[i] + ")";

            if (i != line.length - 1) text[i] += ',';

            if (type == "SDF" || type == "GRID_SDF") {
              NUM_SDFS++;
            } else if (type == "PLANE" || type == "SPHERE" || type == "BOX") {
              U_SPHERE |= type == "SPHERE";
              U_PLANE |= type == "PLANE";
              U_BOX |= type == "BOX";
              NUM_MESHES++;
            } else if (type == "TRIANGLE") {
              NUM_MODELS++;
            } else {
              return alert("There's no such thing as " + type);
            }
          }

          if (light_indices.length == 0) light_indices.push(-1);

          sandbox.scene = `//--------------------- EUCLIDEAN/QUADRIC PARAMS --------------------------------

const bool U_EUCLIDEAN = ` + (NUM_MESHES > 0) + `;    // using Euclidean meshes?
const bool U_SPHERE = ` + Boolean(U_SPHERE) + `;       // using Euclidean sphere?
const bool U_PLANE = ` + Boolean(U_PLANE) + `;        // using Euclidean plane?
const bool U_BOX = ` + Boolean(U_BOX) + `;         // using Non-Euclidean box?
const bool U_SDF = ` + (NUM_SDFS > 0) + `;          // using SDF meshes?

const lowp int NUM_MESHES = ` + NUM_MESHES + `;
const lowp int NUM_SDFS   = ` + NUM_SDFS + `;
const lowp int NUM_MODELS = ` + NUM_MODELS + `;

const Mesh meshes[NUM_MESHES + NUM_SDFS + NUM_MODELS] = Mesh[](
` + text.join("\n") + `
);

// light index
const lowp int light_index[` + light_indices.length + `] = int[](
` + light_indices.join(", ") + `
);`;

          let sdf_html = [];
          sandbox.sdf_meshes = [];
          for (let i = 0; i < NUM_SDFS; i++) {

            let el = $("#sdf" + i).val() || 0;

            if (i == 0) sdf_html.push("SDF meshes");
            sdf_html.push("<div class=\"input-field col s12\">")
            sdf_html.push("<select id = 'sdf" + i + "' onchange='$(\"#compileBtn\").css(\"background\", \"linear-gradient(135deg, #dc2626, #ef4444)\"); is_live = false; $(\"#liveBtn\").css(\"background-color\", \"rgb(105, 105, 105)\");'>");

            let curr_val = 0;

            sdf_html.push("<option value='" + curr_val + "' " + (curr_val == el ? "selected" : "") + ">Box</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">RoundBox</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">Sphere</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">TriPrism</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">Cone</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">MengerSponge</option>");
            sdf_html.push("<option value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">Mandelbulb</option>");
            sdf_html.push("<option disabled value='" + ++curr_val + "' " + (curr_val == el ? "selected" : "") + ">(BiDir)Test0</option>");

            sdf_html.push("</select>");
            sdf_html.push("</div>");

            if (el == 0)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(sdBox(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.xyz), " + i.toFixed(4) + ");");
            else if (el == 1)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(udRoundBox(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.xyz, meshes[NUM_MESHES + " + i + "].joker.w), " + i.toFixed(4) + ");");
            else if (el == 2)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(sdSphere(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.x), " + i.toFixed(4) + ");");
            else if (el == 3)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(sdTriPrism(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.xy), " + i.toFixed(4) + ");");
            else if (el == 4)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(sdCone(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.xyz), " + i.toFixed(4) + ");");
            else if (el == 5)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(MengerSponge(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.xyz), " + i.toFixed(4) + ");");
            else if (el == 6)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(Mandelbulb(p-meshes[NUM_MESHES + " + i + "].pos), " + i.toFixed(4) + ");");
            else if (el == 7)
              sandbox.sdf_meshes.push("sdf_meshes[" + i + "] = vec2(BiDirTest0(p-meshes[NUM_MESHES + " + i + "].pos, meshes[NUM_MESHES + " + i + "].joker.x), " + i.toFixed(4) + ");");

          }

          // update sdf_meshes selector
          $("#sdf_meshes").html(sdf_html.join("\n"));
          $('select').material_select();

          // Mark that recompilation is needed for scene changes
          if (el.dn_highlight === false) {
            markNeedsRecompilation();
          }
        }
      } else {
        return console.error();
      }

      rendering = false;
      // Only mark for recompilation if this is a user-initiated change (not internal updates)
      if (el.dn_highlight == false || el.type == "checkbox" || el.type == "range") {
        // Scene changes and checkbox/range changes need recompilation
        // No need to call markNeedsRecompilation() again since it's already called above for specific cases
      }
      sandbox.clear();
      sandbox.passes = 0;
    }

    function size_select(val) {
      sandbox.resize(val);
      // Update debug labels after resize
      if (sandbox.showAllBuffers) {
        setTimeout(updateDebugLabels, 100); // Small delay to ensure resize is complete
      }
    }

    function scene_select(val) {
      let scene_el = document.getElementById("scene");
      let enabled = [false, false, false];

      if (val == 0) { // Default Scene
        scene_el.value = `MAT_METAL, SDF, vec3(0.0, -0.49, 0.0), vec4(1.0)
MAT_WHITE, SDF, vec3(0.0, -1.6, -0.2), vec4(1.5,0.1,1.5,0.0)`;

        enabled[0] = true;
        enabled[1] = false;
        enabled[2] = true;

        sandbox.setAnimatedMode(false);
        $("#animation_status").hide();
        $("#temporal_accumulation_slider").hide();
        updateUISliders(false);

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(0);
        $("#sdf1").val(0);
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 3.0);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 1) {
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(2.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(2.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(2.0)
MAT_LIGHT_4_TEX, SPHERE, vec3(0.0,1.5,-1.5), vec4(0.5)
MAT_REFR_CLEAR, SPHERE, vec3(0.0), vec4(0.5)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });

        sandbox.camera.origin = new Vector3(0.0, 0.0, 1.99);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
        markNeedsRecompilation();
      } else if (val == 2) {
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(2.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(2.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(2.0)
MAT_LIGHT_4, SPHERE, vec3(0.0,1.5,1.5), vec4(0.5)
MAT_WHITE, SDF, vec3(0.0), vec4(0.0)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(6);
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 1.99);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 3) {
        scene_el.value = `MAT_COAT_WAX, SDF, vec3(0.0), vec4(1.0)`;

        enabled[0] = true;
        enabled[1] = false;
        enabled[2] = true;

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(5);
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 2.0);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 4) { // MIS Demo Scene
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(2.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(2.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(2.0)
MAT_LIGHT_4, SPHERE, vec3(0.0,1.8,0.0), vec4(0.05)
MAT_WHITE, SDF, vec3(0.0, 1.0, 0.0), vec4(0.8, 0.1, 0.8, 0.0)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(0); // Box SDF to block the light
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 1.99);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 5) { // ReSTIR Demo Scene - Complex scene with many lights
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(2.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(2.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(2.0)
MAT_LIGHT_4, SPHERE, vec3(-0.8, 1.8, -0.8), vec4(0.03)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.8, 1.8, -0.8), vec4(0.03)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-0.8, 1.8, 0.8), vec4(0.03)
MAT_LIGHT_4, SPHERE, vec3(0.8, 1.8, 0.8), vec4(0.03)
MAT_LIGHT_4, SPHERE, vec3(0.0, 1.8, 0.0), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.4, 1.6, -0.4), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.4, 1.6, -0.4), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(-0.4, 1.6, 0.4), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.4, 1.6, 0.4), vec4(0.02)
MAT_REFR_CLEAR, SPHERE, vec3(-0.5, -0.5, 0.0), vec4(0.4)
MAT_MIRROR, SPHERE, vec3(0.5, -0.5, 0.0), vec4(0.4)
MAT_WHITE, SDF, vec3(0.0, 0.0, 0.0), vec4(0.3, 0.05, 0.3, 0.0)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        // Enable ReSTIR for multi-light scene
        $("#use_restir").prop('checked', true);
        sandbox.defines[4] = "#define USE_RESTIR";
        sandbox.constants[9] = "const bool use_restir = true;";

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(1); // RoundBox SDF in center
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 1.99);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 6) { // ReSTIR Heavy Demo Scene - Many lights to showcase ReSTIR advantages
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(3.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(3.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(3.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(3.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(3.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(3.0)
MAT_LIGHT_4, SPHERE, vec3(-1.2, 1.9, -1.2), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.6, 1.9, -1.2), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.0, 1.9, -1.2), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(0.6, 1.9, -1.2), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(1.2, 1.9, -1.2), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-1.2, 1.9, -0.6), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(-0.6, 1.9, -0.6), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.0, 1.9, -0.6), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.6, 1.9, -0.6), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(1.2, 1.9, -0.6), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-1.2, 1.9, 0.0), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-0.6, 1.9, 0.0), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(0.0, 1.9, 0.0), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.6, 1.9, 0.0), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(1.2, 1.9, 0.0), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(-1.2, 1.9, 0.6), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.6, 1.9, 0.6), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.0, 1.9, 0.6), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(0.6, 1.9, 0.6), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(1.2, 1.9, 0.6), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-1.2, 1.9, 1.2), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(-0.6, 1.9, 1.2), vec4(0.02)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.0, 1.9, 1.2), vec4(0.02)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.6, 1.9, 1.2), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(1.2, 1.9, 1.2), vec4(0.02)
MAT_LIGHT_4, SPHERE, vec3(-0.9, 1.5, -0.9), vec4(0.015)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.3, 1.5, -0.9), vec4(0.015)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.3, 1.5, -0.9), vec4(0.015)
MAT_LIGHT_4, SPHERE, vec3(0.9, 1.5, -0.9), vec4(0.015)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.9, 1.5, -0.3), vec4(0.015)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-0.3, 1.5, -0.3), vec4(0.015)
MAT_LIGHT_4, SPHERE, vec3(0.3, 1.5, -0.3), vec4(0.015)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.9, 1.5, -0.3), vec4(0.015)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-0.9, 1.5, 0.3), vec4(0.015)
MAT_LIGHT_4, SPHERE, vec3(-0.3, 1.5, 0.3), vec4(0.015)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.3, 1.5, 0.3), vec4(0.015)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.9, 1.5, 0.3), vec4(0.015)
MAT_LIGHT_4, SPHERE, vec3(-0.9, 1.5, 0.9), vec4(0.015)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.3, 1.5, 0.9), vec4(0.015)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.3, 1.5, 0.9), vec4(0.015)
MAT_LIGHT_4, SPHERE, vec3(0.9, 1.5, 0.9), vec4(0.015)
MAT_REFR_CLEAR, SPHERE, vec3(-0.7, -0.5, 0.0), vec4(0.3)
MAT_MIRROR, SPHERE, vec3(0.7, -0.5, 0.0), vec4(0.3)
MAT_WHITE, SDF, vec3(0.0, 0.0, 0.0), vec4(0.4, 0.05, 0.4, 0.0)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        // Enable ReSTIR for heavy multi-light scene
        $("#use_restir").prop('checked', true);
        sandbox.defines[4] = "#define USE_RESTIR";
        sandbox.constants[9] = "const bool use_restir = true;";

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(1); // RoundBox SDF in center
        $('select').material_select();

        sandbox.camera.origin = new Vector3(0.0, 0.0, 2.5);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);
      } else if (val == 7) { // Animated ReSTIR Scene - Real-time optimized
        scene_el.value = `MAT_WHITE, PLANE, vec3(0.0, 1.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, -1.0, 0.0), vec4(2.0)
MAT_GREEN, PLANE, vec3(1.0, 0.0, 0.0), vec4(2.0)
MAT_RED, PLANE, vec3(-1.0, 0.0, 0.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, 1.0), vec4(2.0)
MAT_WHITE, PLANE, vec3(0.0, 0.0, -1.0), vec4(2.0)
MAT_LIGHT_4, SPHERE, vec3(0.0, 1.7, 0.0), vec4(0.04)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.8, 1.5, 0.8), vec4(0.03)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-0.8, 1.5, 0.8), vec4(0.03)
MAT_LIGHT_4, SPHERE, vec3(0.8, 1.5, -0.8), vec4(0.03)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(-0.8, 1.5, -0.8), vec4(0.03)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(0.0, 1.3, 1.2), vec4(0.025)
MAT_LIGHT_4, SPHERE, vec3(1.2, 1.3, 0.0), vec4(0.025)
MAT_LIGHT_CANDLE_4, SPHERE, vec3(0.0, 1.3, -1.2), vec4(0.025)
MAT_LIGHT_HALOGEN_4, SPHERE, vec3(-1.2, 1.3, 0.0), vec4(0.025)
MAT_REFR_CLEAR, SPHERE, vec3(-0.4, -0.3, 0.4), vec4(0.35)
MAT_MIRROR, SPHERE, vec3(0.4, -0.3, -0.4), vec4(0.35)
MAT_METAL, SDF, vec3(0.0, -0.2, 0.0), vec4(0.3, 0.05, 0.3, 0.0)`;

        enabled[0] = false;
        enabled[1] = false;
        enabled[2] = true;

        // Enable animated mode with optimized settings
        sandbox.setAnimatedMode(true);

        // Update UI to reflect ReSTIR being enabled for animated scenes
        $("#use_restir").prop('checked', true);

        updateParams({
          type: 'textarea',
          id: 'scene',
          dn_highlight: false,
          text: $("#scene").val()
        });
        $("#sdf0").val(1); // RoundBox SDF in center
        $('select').material_select();

        // Update UI sliders to reflect real-time settings
        updateUISliders(true);

        // Show animation status and performance info
        $("#animation_status").show();
        $("#temporal_accumulation_slider").show();

        // Update performance info
        $("#animation_status").html("ðŸŽ¬ ANIMATED SCENE - Real-time ReSTIR Demo<br><small>Optimized: 6 bounces, 2 diffuse, 64 marching steps</small>");

        sandbox.camera.origin = new Vector3(0.0, 0.0, 1.99);
        sandbox.camera.lookat = new Vector3(0.0, 0.0, -1.0);

        // Enable animation for this scene
        sandbox.animatedScene = true;
        sandbox.animationStartTime = performance.now();

        // Show animation status and temporal accumulation slider
        $("#animation_status").show();
        $("#temporal_accumulation_slider").show();

        markNeedsRecompilation();
      }

      // Reset animation for non-animated scenes
      if (val !== 7) {
        sandbox.setAnimatedMode(false);
        // Update UI to reflect ReSTIR being disabled for static scenes
        $("#use_restir").prop('checked', false);
        // Hide animation status and temporal accumulation slider
        $("#animation_status").hide();
        $("#temporal_accumulation_slider").hide();
      }

      // Cubemap
      sandbox.defines[0] = enabled[0] ? "#define USE_CUBEMAP" : "//#define USE_CUBEMAP";
      $("#u_cubemap").prop('checked', enabled[0]);

      // Procedural Sky - ensure mutual exclusion with cubemap
      if (enabled[0]) {
        // If cubemap is enabled, disable procedural sky
        sandbox.defines[1] = "//#define USE_PROCEDURAL_SKY";
        $("#u_procedural_sky").prop('checked', false);
      } else {
        // If cubemap is disabled, procedural sky can be enabled
        sandbox.defines[1] = "//#define USE_PROCEDURAL_SKY";
        $("#u_procedural_sky").prop('checked', false);
      }

      // Bi-Directional Pathtracing
      // sandbox.defines[3] = enabled[1] ? "#define USE_BIDIRECTIONAL" : "//#define USE_BIDIRECTIONAL";
      // $("#u_biDirectional").prop('checked', enabled[1]);

      // sample lights
      sandbox.constants[7] = "const bool sample_lights = " + enabled[2] + ";";
      $("#sample_lights").prop('checked', enabled[2]);

      $("#intro #stats").html("<b>camera</b> pos: " + sandbox.camera.origin.x.toFixed(3) + ", " + sandbox.camera.origin.y.toFixed(3) + ", " + sandbox.camera.origin.z.toFixed(3) +
        " | dir: " + sandbox.camera.lookat.x.toFixed(3) + ", " + sandbox.camera.lookat.y.toFixed(3) + ", " + sandbox.camera.lookat.z.toFixed(3) + "<br>" +
        " fov: " + sandbox.camera.fov + ", aperture: " + sandbox.camera.aperture.toFixed(3) + ", focal length: " + sandbox.camera.focalLength.toFixed(3));

      sandbox.gl.useProgram(sandbox.frontTarget.program);

      sandbox.gl.uniform3f(sandbox.frontTarget.camPosID, sandbox.camera.origin.x, sandbox.camera.origin.y, sandbox.camera.origin.z);
      sandbox.gl.uniform3f(sandbox.frontTarget.camLookAtID, sandbox.camera.lookat.x, sandbox.camera.lookat.y, sandbox.camera.lookat.z);

      scene_el.style.height = "1px";
      scene_el.style.height = scene_el.scrollHeight + "px";

      // Mark that recompilation is needed when scene is changed
      markNeedsRecompilation();
    }

    function recompile() {
      if (!needsRecompilation()) return console.info("There is no need to recompile the shader.");

      console.log("Recompiling shader with defines:", sandbox.defines);
      console.log("Recompiling shader with constants:", sandbox.constants);

      updateParams({
        type: 'textarea',
        id: 'scene',
        dn_highlight: true,
        text: $("#scene").val()
      });

      try {
        sandbox.gl.detachShader(sandbox.frontTarget.program, sandbox.shaders[shaders[1].name]);
      } catch (e) {
        console.warn(e.message)
      };
      shaders[1].string = parseShader(shaders[1].filepath, sandbox);
      console.log("New shader compiled successfully");
      sandbox.createShader(shaders[1]);
      sandbox.gl.attachShader(sandbox.frontTarget.program, sandbox.shaders[shaders[1].name]);
      sandbox.gl.linkProgram(sandbox.frontTarget.program);
      sandbox.updateFrontTarget();

      console.clear();
      $("#compileBtn").css("background", "linear-gradient(135deg, #6b7280, #9ca3af)");
    }

    function needsRecompilation() {
      return $("#compileBtn").css("background").indexOf("rgb(220, 38, 38)") !== -1 ||
        $("#compileBtn").css("background").indexOf("#dc2626") !== -1;
    }

    function markNeedsRecompilation() {
      $("#compileBtn").css("background", "linear-gradient(135deg, #dc2626, #ef4444)");
      is_live = false;
      $("#liveBtn").css("background-color", "rgb(105, 105, 105)");
    }

    function autoRecompileIfNeeded() {
      if (needsRecompilation()) {
        console.log("Auto-recompiling shader before rendering...");
        recompile();
        return true;
      }
      return false;
    }

    function RenderLoop() {
      stats.begin();
      if (rendering) sandbox.render();
      stats.end();

      // display rendering info
      let t = (performance.now() - sandbox.loadTime) / 1000;
      // tile rendering
      if (sandbox.tile_rendering && sandbox.tile_size != 0 && sandbox.passes >= sandbox.max_passes) sandbox.updateTile();

      if (is_live || sandbox.animatedScene) {
        window.requestAnimFrame(RenderLoop)
      } else {
        if (rendering && sandbox.passes < sandbox.max_passes) {
          let progress = Math.round(100 * sandbox.passes / sandbox.max_passes);
          $("#ff .progress .determinate").css("width", progress + '%');
          !console.log("%cProgress: ", 'color: #00ff14', progress + '% (' + t + 's)') && window.requestAnimFrame(RenderLoop);
        } else {
          !console.log("%cStopped!", 'color: #ff0000') && console.log("%cTotal time: " + t + " s,\nPasses: " + sandbox.passes, 'color: #0096FF');
          rendering = false;
          $("#ff .progress .determinate").css("width", 0 + '%');
          document.getElementById("renderBtn").innerHTML = "RENDER";
        }
      }
    }

    function updateDebugLabels() {
      if (!sandbox.showAllBuffers) return;
      
      const canvas = sandbox.canvas;
      const rect = canvas.getBoundingClientRect();
      const dividerX = sandbox.debugDividerPos[0];
      const dividerY = sandbox.debugDividerPos[1];
      
      // Calculate positions for each label (3x2 grid)
      const labelMain = document.getElementById("labelMain");
      const labelEffectiveness = document.getElementById("labelEffectiveness");
      const labelTemporal = document.getElementById("labelTemporal");
      const labelSamples = document.getElementById("labelSamples");
      const labelAge = document.getElementById("labelAge");
      const labelContribution = document.getElementById("labelContribution");
      
      // Top row (3 columns)
      if (labelMain) {
        labelMain.style.left = (33.33 * 0.5) + "%";
        labelMain.style.top = "8%";
        labelMain.style.transform = "translate(-50%, 0)";
      }
      
      if (labelEffectiveness) {
        labelEffectiveness.style.left = (33.33 + 33.33 * 0.5) + "%";
        labelEffectiveness.style.top = "8%";
        labelEffectiveness.style.transform = "translate(-50%, 0)";
      }
      
      if (labelTemporal) {
        labelTemporal.style.left = (66.66 + 33.33 * 0.5) + "%";
        labelTemporal.style.top = "8%";
        labelTemporal.style.transform = "translate(-50%, 0)";
      }
      
      // Bottom row (3 columns)
      if (labelSamples) {
        labelSamples.style.left = (33.33 * 0.5) + "%";
        labelSamples.style.top = "58%";
        labelSamples.style.transform = "translate(-50%, 0)";
      }
      
      if (labelAge) {
        labelAge.style.left = (33.33 + 33.33 * 0.5) + "%";
        labelAge.style.top = "58%";
        labelAge.style.transform = "translate(-50%, 0)";
      }
      
      if (labelContribution) {
        labelContribution.style.left = (66.66 + 33.33 * 0.5) + "%";
        labelContribution.style.top = "58%";
        labelContribution.style.transform = "translate(-50%, 0)";
      }
    }

    function toggleBufferDisplay() {
      sandbox.toggleBufferDisplay();
      
      // Update button text and styling
      const btn = document.getElementById("debugBtn");
      btn.innerHTML = sandbox.showAllBuffers ? "Show Main Buffer" : "Show All Buffers";
      
      // Show/hide debug labels
      const debugLabels = document.getElementById("debugLabels");
      if (sandbox.showAllBuffers) {
        btn.classList.add("active");
        debugLabels.classList.add("active");
        updateDebugLabels();
        console.log("%cReSTIR Debug view enabled - analyzing ReSTIR performance", 'color: #ff6b35; font-weight: bold');
        console.log("%câ€¢ Top-left: Final rendered image", 'color: #ff6b35');
        console.log("%câ€¢ Top-center: ReSTIR effectiveness (green=good, red=poor)", 'color: #ff6b35');
        console.log("%câ€¢ Top-right: Temporal reuse analysis (green=improved, red=degraded)", 'color: #ff6b35');
        console.log("%câ€¢ Bottom-left: Sample count visualization (M values)", 'color: #ff6b35');
        console.log("%câ€¢ Bottom-center: Reservoir age and light index mapping", 'color: #ff6b35');
        console.log("%câ€¢ Bottom-right: Direct light contribution analysis", 'color: #ff6b35');
        console.log("%câ€¢ This enhanced view now properly uses u_restir_history1_aux!", 'color: #00ff00; font-weight: bold');
      } else {
        btn.classList.remove("active");
        debugLabels.classList.remove("active");
        console.log("%cDebug view disabled - showing main buffer only", 'color: #27ff00');
      }
    }

    function draw() {
      // Auto-recompile if needed before starting to render
      if (!rendering && needsRecompilation()) {
        console.log("Auto-recompiling shader before rendering...");
        recompile();
      }

      rendering = !rendering;
      document.getElementById("renderBtn").innerHTML = rendering ? "STOP" : "RENDER";
      if (rendering) sandbox.clear();

      console.log("%cStarted Rendering Sequence \n", 'color: #872190');
      console.log("%cOutput resolution: " + sandbox.canvas.width.toString() + "x" + sandbox.canvas.height.toString() + "\n", 'color: #5800b1');
      console.log("%cPasses: " + sandbox.max_passes, 'color: #5800b1');
      if (rendering) !(sandbox.passes = 0) && (sandbox.loadTime = performance.now()) && RenderLoop();
    }

    // Update UI sliders to reflect current rendering mode
    function updateUISliders(isAnimated) {
      console.log("%cUpdating UI sliders for " + (isAnimated ? "animated" : "static") + " scene", 'color: #9b59b6');

      if (isAnimated) {
        // Set animated scene values
        $("#max_bounces").val(6);
        $("#max_diff").val(2);
        $("#max_spec").val(2);
        $("#max_trans").val(4);
        $("#max_scatter").val(4);
        $("#m_steps").val(64);
        console.log("%cSet sliders to animated values: 6 bounces, 2 diffuse, 64 marching steps", 'color: #ff6b35');
      } else {
        // Restore static scene values
        $("#max_bounces").val(12);
        $("#max_diff").val(4);
        $("#max_spec").val(4);
        $("#max_trans").val(12);
        $("#max_scatter").val(12);
        $("#m_steps").val(128);
        console.log("%cRestored sliders to static values: 12 bounces, 4 diffuse, 128 marching steps", 'color: #27ff00');
      }
    }

    $(document).ready(function () {
      $('select').material_select();
      $('.modal').modal();

      $("#intro #stats").html("<b>camera</b> pos: " + sandbox.camera.origin.x.toFixed(3) + ", " + sandbox.camera.origin.y.toFixed(3) + ", " + sandbox.camera.origin.z.toFixed(3) +
        " | dir: " + sandbox.camera.lookat.x.toFixed(3) + ", " + sandbox.camera.lookat.y.toFixed(3) + ", " + sandbox.camera.lookat.z.toFixed(3) + "<br>" +
        " fov: " + sandbox.camera.fov + ", aperture: " + sandbox.camera.aperture.toFixed(3) + ", focal length: " + sandbox.camera.focalLength.toFixed(3));

      updateParams({
        type: 'textarea',
        id: 'scene',
        dn_highlight: true,
        text: $("#scene").val()
      });
    });

  </script>
</body>

</html>